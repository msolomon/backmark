// Generated by CoffeeScript 1.8.0
var ChromePromisifier, addToZip, backupUrl, chromePromisify, cleanFilename, closeZipWriter, combineZipFiles, downloadPage, downloadPageWithAccept, eraseStorage, fetchContent, getBookmarks, getBookmarksInfo, getConcurrency, getFailedAtDate, getFailedAtTimestamp, getFailedAtTimestamps, getInfo, getOneInfo, getPage, getPrefixed, getRetryDays, getSavedAtDate, getSavedAtDates, getSavedAtTimestamp, getSavedAtTimestamps, getSingle, getSinglePrefixed, linearizeTree, makeFilename, mkBaseDownload, mkDataUriZipReader, mkEmptyZip, mkFullBundle, mkKeepAlive, mkTabLoaded, readBlob, recordFailed, recordSaved, removeEntry, removeExactUrlFromHistory, removeUrlFromHistory, runBackup, runMissingBackup, savePage, saveSingle, setConcurrency, setRetryDays, zipPage;

ChromePromisifier = function(originalMethod) {
  return function() {
    var args, self;
    args = [].slice.call(arguments);
    self = this;
    return new Promise(function(resolve, reject) {
      var checkedResolve;
      checkedResolve = (function(_this) {
        return function(v) {
          if (chrome.runtime.lastError) {
            return reject(chrome.runtime.lastError);
          } else {
            return resolve(v);
          }
        };
      })(this);
      args.push(checkedResolve);
      return originalMethod.apply(self, args);
    });
  };
};

chromePromisify = function(pkg) {
  return Promise.promisifyAll(pkg, {
    promisifier: ChromePromisifier
  });
};

chromePromisify(chrome.bookmarks);

chromePromisify(chrome.downloads);

chromePromisify(chrome.history);

chromePromisify(chrome.tabs);

chromePromisify(chrome.storage.local);

chromePromisify(chrome.pageCapture);

chromePromisify(chrome.runtime);

if (zip) {
  zip.workerScriptsPath = "lib/";
}

fetchContent = function(url) {
  return Promise.resolve($.get(url)).then(function(jqXhr) {
    return jqXhr;
  });
};

readBlob = function(url, mime) {
  return fetchContent(url).then(function(data) {
    return new Blob([data], {
      type: mime || ''
    });
  });
};

combineZipFiles = function(targetWriter, sourceReader) {
  return new Promise(function(resolve, reject) {
    return sourceReader.getEntries(resolve);
  }).then(function(entries) {
    return Promise.resolve(entries).each(function(e) {
      var tmpWriter;
      tmpWriter = new zip.BlobWriter();
      return new Promise(function(resolve, reject) {
        return e.getData(tmpWriter, resolve);
      }).then(function(data) {
        return addToZip(targetWriter, e.filename, new zip.BlobReader(data));
      });
    });
  }).then(function() {
    return targetWriter;
  });
};

mkDataUriZipReader = function(dataUri) {
  return new Promise(function(resolve, reject) {
    return zip.createReader(new zip.Data64URIReader(dataUri), resolve, reject);
  });
};

addToZip = function(zipWriter, filename, zipReader) {
  return new Promise(function(resolve, reject) {
    return zipWriter.add(filename, zipReader, resolve, (function(p, t) {
      return null;
    }), {
      level: 9
    });
  }).then(function() {
    return zipWriter;
  });
};

closeZipWriter = function(zw) {
  return new Promise(function(resolve, reject) {
    return zw.close(resolve);
  });
};

mkEmptyZip = function() {
  return new Promise(function(resolve, reject) {
    return zip.createWriter(new zip.Data64URIWriter('application/zip'), resolve, reject);
  });
};

mkBaseDownload = function() {
  return readBlob("rename-all-osx-linux.sh", "application/x-sh").then(function(bashRename) {
    return readBlob("rename-all-windows.bat", "application/x-bat").then(function(windowsRename) {
      return mkEmptyZip().then(function(zw) {
        return addToZip(zw, "rename-all-osx-linux", new zip.BlobReader(bashRename));
      }).then(function(zw) {
        return addToZip(zw, "rename-all-windows.change-to-bat", new zip.BlobReader(windowsRename));
      });
    });
  });
};

zipPage = function(url, blob) {
  return mkEmptyZip().then(function(zw) {
    return addToZip(zw, makeFilename(cleanFilename(url), 'change-to-mhtml'), new zip.BlobReader(blob));
  }).then(closeZipWriter);
};

savePage = function(url, dataUri) {
  return saveSingle("bookmark::" + url, dataUri);
};

getPage = function(url) {
  return getSingle("bookmark::" + url);
};

mkFullBundle = function(urlsToDataUri) {
  return mkBaseDownload().then(function(base) {
    return Promise.resolve(_.keys(urlsToDataUri)).map(function(url) {
      return mkDataUriZipReader(urlsToDataUri[url]).then(function(reader) {
        return combineZipFiles(base, reader);
      });
    }).then(function() {
      return base;
    });
  }).then(closeZipWriter);
};

cleanFilename = function(filename) {
  return filename.replace(/\W+/g, '-').replace(/^https?/, '').replace(/(^-+|-+$)/g, '').replace(/^www-/, '');
};

makeFilename = function(filename, extension) {
  return cleanFilename(filename) + "." + extension;
};

downloadPageWithAccept = function(dataUri, filename) {
  return chrome.tabs.createAsync({
    url: 'acceptDanger.html',
    active: true,
    selected: true
  }).then(function(tab) {
    return mkTabLoaded(tab.id);
  }).then(function(tab) {
    return chrome.tabs.sendMessage(tab.id, {
      msg: 'download',
      url: dataUri,
      filename: cleanFilename(filename) + ".zip"
    });
  });
};

downloadPage = function(dataUri, filename) {
  return chrome.downloads.downloadAsync({
    url: dataUri,
    filename: cleanFilename(filename) + ".zip",
    saveAs: false
  }).then(function(downloadId) {
    return chrome.downloads.acceptDangerAsync(downloadId);
  });
};

recordSaved = function(url) {
  console.log('saved ', url);
  return saveSingle("savedat::" + url, Date.now());
};

recordFailed = function(url) {
  console.log('failed ', url);
  return saveSingle("failedat::" + url, Date.now());
};

saveSingle = function(k, v) {
  var store;
  store = {};
  store[k] = v;
  return chrome.storage.local.setAsync(store);
};

getSingle = function(k) {
  return chrome.storage.local.getAsync(k).then(function(data) {
    return data[k];
  });
};

getSinglePrefixed = function(prefix, k) {
  return getSingle(prefix + k);
};

getSavedAtTimestamp = function(k) {
  return getSinglePrefixed("savedat::", k);
};

getSavedAtDate = function(k) {
  return getSinglePrefixed("savedat::", k).then(function(v) {
    if (v) {
      return new Date(v);
    } else {
      return v;
    }
  });
};

getFailedAtTimestamp = function(k) {
  return getSinglePrefixed("failedat::", k);
};

getFailedAtDate = function(k) {
  return getSinglePrefixed("failedat::", k).then(function(v) {
    if (v) {
      return new Date(v);
    } else {
      return v;
    }
  });
};

getConcurrency = function() {
  return getSingle("settings::concurrency").then(function(v) {
    return v || 3;
  });
};

setConcurrency = function(concurrency) {
  return saveSingle("settings::concurrency", concurrency);
};

getRetryDays = function() {
  return getSingle("settings::retrydays").then(function(v) {
    return v || 7;
  });
};

setRetryDays = function(retrydays) {
  return saveSingle("settings::retrydays", retrydays);
};

removeEntry = function(url) {
  chrome.storage.local.remove("bookmark::" + url);
  chrome.storage.local.remove("savedat::" + url);
  return chrome.storage.local.remove("failedat::" + url);
};

eraseStorage = function() {
  return chrome.storage.local.clearAsync();
};

mkTabLoaded = function(tabId) {
  return new Promise(function(resolve, reject) {
    var listener;
    return listener = chrome.tabs.onUpdated.addListener(function(id, info, tab) {
      if (id === tabId && info.status === 'complete') {
        chrome.tabs.onUpdated.removeListener(listener);
        return resolve(tab);
      }
    });
  });
};

linearizeTree = function(nodes) {
  var go;
  go = function(nodes) {
    return nodes.map(function(node) {
      if (node.hasOwnProperty('children')) {
        return [node].concat(linearizeTree(node.children));
      } else {
        return node;
      }
    });
  };
  return go(nodes).reduce((function(a, b) {
    return a.concat(b);
  }), []);
};

getBookmarks = function() {
  return chrome.bookmarks.getTreeAsync().then(function(tree) {
    return _.filter(linearizeTree(tree), function(n) {
      return n.hasOwnProperty('url');
    });
  });
};

getPrefixed = function(ids, prefix) {
  var l;
  l = prefix.length;
  return chrome.storage.local.getAsync(ids.map(function(id) {
    return prefix + id;
  })).then(function(result) {
    return _.mapKeys(result, function(v, k) {
      return k.slice(l);
    });
  });
};

getSavedAtTimestamps = function(urls) {
  return getPrefixed(urls, "savedat::");
};

getSavedAtDates = function(urls) {
  return getSavedAtTimestamps(urls).then(function(results) {
    return _.mapValues(results, function(v, k) {
      return new Date(v);
    });
  });
};

getFailedAtTimestamps = function(urls) {
  return getPrefixed(urls, "failedat::");
};

getOneInfo = function(bookmark) {
  return getInfo([bookmark]).then(function(bookmarks) {
    return bookmarks[0];
  });
};

getInfo = function(bookmarks) {
  var urls;
  urls = bookmarks.map(function(b) {
    return b.url;
  });
  return Promise.join(getSavedAtTimestamps(urls), getFailedAtTimestamps(urls), function(allSavedAt, allFailedAt) {
    return bookmarks.map(function(b) {
      return _.assign(b, {
        savedAt: allSavedAt[b.url],
        failedAt: allFailedAt[b.url],
        favicon: 'chrome://favicon/' + b.url
      });
    });
  });
};

getBookmarksInfo = function() {
  return getBookmarks().then(getInfo);
};

removeExactUrlFromHistory = function(url) {
  return chrome.history.deleteUrlAsync({
    url: url
  });
};

removeUrlFromHistory = function(url, title) {
  return chrome.history.getVisitsAsync({
    url: url
  }).then(function(results) {
    if (results.length > 0) {
      return removeExactUrlFromHistory(url);
    } else {
      return chrome.history.searchAsync({
        text: title + " " + url,
        startTime: new Date() - 30 * 1000,
        maxResults: 1
      }).then(function(results) {
        if (results.length > 0 && results[0].hasOwnProperty('url')) {
          return removeExactUrlFromHistory(results[0].url);
        }
      });
    }
  });
};

backupUrl = function(url) {
  var t;
  t = null;
  return chrome.tabs.createAsync({
    url: url,
    active: false,
    selected: false
  }).then(function(tab) {
    t = tab;
    return mkTabLoaded(tab.id);
  }).then(function(tab) {
    return chrome.pageCapture.saveAsMHTMLAsync({
      tabId: tab.id
    }).then(function(mhtml) {
      return zipPage(url, mhtml);
    }).then(function(zip) {
      return savePage(url, zip);
    }).then(function(evt) {
      if (chrome.runtime.lastError) {
        console.log(chrome.runtime.lastError);
      } else {
        recordSaved(url);
      }
      removeUrlFromHistory(tab.url, tab.title);
      return chrome.tabs.removeAsync(tab.id);
    });
  }).timeout(15000)["catch"](Promise.TimeoutError, function(e) {
    console.log('timed out loading page:', url);
    recordFailed(url);
    return chrome.tabs.removeAsync(t.id);
  });
};

runMissingBackup = function() {
  return getBookmarks().then(function(bs) {
    return runBackup(bs, false);
  });
};

runBackup = function(bookmarks, force) {
  var keepalive;
  keepalive = mkKeepAlive();
  return getRetryDays().then(function(retryDays) {
    var isRecent;
    isRecent = function(ts) {
      return (new Date() - ts) < retryDays * 24 * 60 * 60 * 1000;
    };
    return getConcurrency().then(function(concurrency) {
      return Promise.resolve(bookmarks).map(function(bookmark) {
        return getOneInfo(bookmark).then(function(bookmark) {
          if (((function() {
            switch (false) {
              case !bookmark.url.startsWith("chrome:"):
                return true;
              case !bookmark.url.startsWith("javascript:"):
                return true;
              case !bookmark.url.startsWith("data:"):
                return true;
              default:
                return false;
            }
          })())) {

          } else if (!force && bookmark.savedAt) {

          } else if (!force && bookmark.failedAt && isRecent(bookmark.failedAt)) {

          } else {
            console.log('backing up', bookmark.url);
            return backupUrl(bookmark.url);
          }
        });
      }, {
        concurrency: concurrency
      });
    })["finally"](function() {
      keepalive.cancel();
      return true;
    });
  });
};

mkKeepAlive = function() {
  var go, port;
  port = chrome.runtime.connect({
    name: "keepalive-" + _.random()
  });
  go = function() {
    return new Promise(function(resolve, reject) {
      return null;
    }).timeout(1000)["catch"](Promise.TimeoutError, function(e) {
      console.log('keepalive');
      return go();
    })["catch"](Promise.CancellationError, function(e) {
      port.disconnect();
      return console.log('cancelled!');
    });
  };
  return go();
};

//# sourceMappingURL=common.js.map
